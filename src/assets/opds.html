<!DOCTYPE html>
<!--

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

-->
<meta charset="utf-8">
<script src="utils.js"></script>
<script>
let baseURI

// very simple OPDS parser
// the basic idea is derived from https://github.com/SamyPesse/xml-schema

const OPDS_NS = 'http://opds-spec.org/2010/catalog'
const THR_NS = 'http://purl.org/syndication/thread/1.0'
const DC_NS = 'http://purl.org/dc/terms/'

const trim = x => x ? x.trim() : x

const link = {
    tag: 'link',
    array: true,
    attrs: {
        href: { transform: x => new URL(x, baseURI).href },
        rel: {},
        type: {},
        title: {},
        count: { tag: 'count', ns: THR_NS },
        facetGroup: { tag: 'facetGroup', ns: OPDS_NS },
        activeFacet: { tag: 'activeFacet', ns: OPDS_NS, transform: x => x === 'true' }
    }
}
const author = {
    tag: 'author',
    array: true,
    fields: { name: {}, uri: {} }
}
const entry = {
    tag: 'entry',
    array: true,
    fields: {
        id: {},
        title: { transform: trim },
        updated: {},
        summary: { transform: trim },
        links: link,
        authors: author,
        categories: {
            tag: 'category',
            array: true,
            attrs: { term: {}, label: {}, scheme: {} }
        },
        publisher: { ns: DC_NS },
        language: { ns: DC_NS },
        content: { transform: trim },
    }
}
const feed = {
    tag: 'feed',
    fields: {
        id: {},
        title: { transform: trim },
        icon: {},
        updated: {},
        links: link,
        authors: author,
        entries: entry
    }
}

const parse = (el, schema) => {
    const attrs = schema.attrs || {}
    const fields = schema.fields || {}
    const attrList = Object.keys(attrs)
    const fieldList = Object.keys(fields)
    if (!attrList.length && !fieldList.length) {
        const transform = schema.transform || (x => x)
        return transform(el.textContent)
    }
    const output = {}
    attrList.forEach(key => {
        const attr = attrs[key]
        const attrName = attr.name || key
        const value = (attr.ns
            ? el.getAttributeNS(attr.ns, attrName)
            : el.getAttribute(attrName)) || attr.default
        const transform = attr.transform || (x => x)
        output[key] = transform(value)
    })
    fieldList.forEach(key => {
        const field = fields[key]
        const tagName = field.tag || key
        const tags = Array.from(el.children)
            .filter(child => child.tagName === tagName)
        if (!tags.length) return
        const values = tags.map(tag => parse(tag, field))
        output[key] = field.array || values.length > 1 ? values : values[0]
    })
    return output
}

const getImage = async (src, token) => {
    const res = await fetch(src)
    const blob = await res.blob()

    const reader = new FileReader()
    reader.readAsDataURL(blob)
    reader.onloadend = () => {
        const base64 = reader.result.split(',')[1]
        dispatch({
            type: 'image',
            payload: base64,
            token
        })
    }
}

const getFeed = (uri, token) => {
    baseURI = uri
    const parser = new DOMParser()
    fetch(uri)
        .then(res => res.text())
        .then(text => parser.parseFromString(text, 'text/xml'))
        .then(doc => {
            const tagName = doc.documentElement.tagName
            if (tagName === 'entry') {
                const payload = parse(doc.documentElement, entry)
                payload.isEntry = true
                dispatch({ type: 'entry', payload, token })
            } else if (tagName === 'feed') {
                const payload = parse(doc.documentElement, feed)
                payload.isEntry = false
                dispatch({ type: 'feed', payload, token })
            } else
                throw new Error(`root element is "${tagName}"; should be "feed" or "entry"`)
        })
        .catch(e => dispatch({
            type: 'error',
            payload: e.toString(),
            token
        }))
}

dispatch({ type: 'ready' })
</script>
